#!/usr/bin/env perl
# -*- coding: ascii -*-
###########################################################################
# clivepass, the login password utility for clive
#
# Copyright (c) 2008,2009 Toni Gundogdu <legatvs@gmail.com>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
###########################################################################

use warnings;
use strict;

binmode(STDOUT, ":utf8");

use Crypt::PasswdMD5 qw(unix_md5_crypt);
use Crypt::Salt qw(salt);
use Crypt::Twofish2;
use Config::Tiny;

# Core modules:
use MIME::Base64 qw(encode_base64 decode_base64);
use Getopt::Long qw(:config bundling);
use Pod::Usage qw(pod2usage);
use Digest::MD5 qw(md5_hex);
use File::Path qw(mkpath);
use File::Find qw(find);
use File::Spec;
use Encode;

my $VERSION = "2.1.1-dev";
my $CONFIGDIR   = $ENV{CLIVEPASS_HOME}
    || File::Spec->catfile($ENV{HOME}, ".config/clive-utils");
my $PASSWDFILE  = File::Spec->catfile($CONFIGDIR, "passwd");

my %opts;
GetOptions(\%opts,
    'create|c', 'add|a=s',  'get|g=s', 'edit|e=s', 'delete|d=s',
    'show|s',   'manual|m', 'help|h',  'version|v' => \&print_version,
) or pod2usage(1);

pod2usage(-exitstatus => 0, -verbose => 1) if $opts{help};
pod2usage(-exitstatus => 0, -verbose => 2) if $opts{manual};

main();

sub main {
    mkpath( [$CONFIGDIR], 1, 0700 );

    if    ( $opts{add} )    { add_login(); }
    elsif ( $opts{create} ) { create_passwd(); }
    elsif ( $opts{edit} )   { edit_login(); }
    elsif ( $opts{delete} ) { delete_login(); }
    elsif ( $opts{get} )    { get_login(); }
    elsif ( $opts{show} )   { show_logins(); }
    else {
        print STDERR "Try --help for more info.\n";
    }
}

sub create_passwd {
    if ( -e $PASSWDFILE ) {
        print "WARN: $PASSWDFILE exists already.\n"
            . "WARN: You are about to overwrite the existing file.\n"
            . "WARN: Hit ctrl-c now if that's not your intention.\n";
    }
    print "Creating $PASSWDFILE.\n";

    my ($phrase, $again);
    $phrase = getpass("Enter a new passphrase: ") while ( ! $phrase );
    print "WARN: Consider using a longer passphrase.\n"
        if ( length($phrase) < 8 );
    $again = getpass("Re-enter the passphrase: ") while ( ! $again );

    print STDERR "error: passphrases did not match\n" and exit
        unless $phrase eq $again;

    my $passwd = Config::Tiny->new;
    $passwd->{_}->{phrase} = unix_md5_crypt($phrase, salt(8));
    $passwd->write($PASSWDFILE);

    return ( passwd => $passwd, phrase => $phrase );
}

sub verify_phrase {
    my ($phrase_hash) = @_;

    print STDERR "error: $PASSWDFILE: phrase hash not found\n" and exit
        unless $phrase_hash;

    my $phrase;
    $phrase = getpass("Enter passphrase: ") while ( ! $phrase );

    if ( unix_md5_crypt($phrase, $phrase_hash) ne $phrase_hash ) {
        print STDERR "error: invalid passphrase\n";
        exit;
    }
    return $phrase;
}

sub get_key {
    my ($dupl_user) = @_;

    print STDERR "error: $PASSWDFILE does not exist, use --create\n"
        and exit if ( ! -e $PASSWDFILE );

    my $passwd = Config::Tiny->read($PASSWDFILE);

    if ( $dupl_user ) {
        my ($id, $pwd) = lookup_login($passwd, $dupl_user);
        print STDERR qq/error: login with the "$dupl_user" /
            . "username exists already\n" and exit if $pwd;
    }

    my $phrase = verify_phrase($passwd->{_}->{phrase});
    my $key = md5_hex($phrase);

    return ($key, $passwd);
}


sub getpass {
    if ( -t STDOUT ) {
        system "stty -echo";
        print shift;
    }
    chomp(my $passwd = <STDIN>);

    if ( -t STDOUT ) {
        print "\n";
        system "stty echo";
    }
    return $passwd;
}

sub new_login {
    my ($key, $passwd, $user) = @_;

    my ($pwd, $again);
    $pwd = getpass("Enter password for $user: ") while ( ! $pwd );
    $again = getpass("Re-enter the password: ") while ( ! $again );

    print STDERR "error: passwords did not match\n" and exit
        unless $pwd eq $again;

    my $c = Crypt::Twofish2->new($key, Crypt::Twofish2::MODE_CBC);

    $passwd->{login}->{$user} =
        encode_base64( $c->encrypt( pack('a16',$pwd) ) );

    $passwd->write($PASSWDFILE);
}

sub add_login {
    my ($key, $passwd) = get_key($opts{add});
    new_login($key, $passwd, $opts{add});
}

sub edit_login {
    my ($key, $passwd) = get_key();
    my ($id, $pwd) = lookup_login($passwd, $opts{edit});

    print STDERR qq/error: no such login with the "$opts{edit}" /
        . "username exists\n" and exit unless $pwd;

    print "WARN: Changing password for the login "
        . qq/with the username "$id".\n/;

    new_login($key, $passwd, $id);
}

sub get_login {
    my ($key, $passwd) = get_key();
    my ($id, $pwd) = lookup_login($passwd, $opts{get});

    print STDERR qq/error: no such login with the "$opts{get}" /
        . "username exists\n" and exit unless $pwd;

    my $c = Crypt::Twofish2->new($key, Crypt::Twofish2::MODE_CBC);
    print "login: " .$opts{get}."=". $c->decrypt(decode_base64($pwd)) ."\n";
}

sub show_logins {
    my $passwd = Config::Tiny->read($PASSWDFILE);
    foreach ( $passwd->{login} ) {
        while ( my ($id, $pwd) = each(%{$_}) ) {
            printf "%20s = %-32s\n", $id, $pwd;
        }
    }
}

sub delete_login {
    my ($key, $passwd) = get_key();
    my ($id, $pwd) = lookup_login($passwd, $opts{delete});

    print STDERR qq/error: no such login with the "$opts{delete}" /
        . "username exists\n" and exit unless $pwd;

    print "WARN: About to delete the login with the username "
        . qq/"$id".\n/ ."> Confirm delete (y/N): ";

    chomp(my $confirm = <STDIN>);
    exit unless $confirm eq "y";

    delete $passwd->{login}->{$id};
    $passwd->write($PASSWDFILE);
}

sub lookup_login {
    my ($passwd, $user) = @_;

    foreach ( $passwd->{login} ) {
        while ( my ($id, $pwd) = each(%{$_}) ) {
            if ( $id eq $user ) {
                return ($id,$pwd);
            }
        }
    }
}

sub print_version {
    my $perl_v  = sprintf "%vd", $^V;
    print
"clivepass version $VERSION  [$^O]
Copyright (c) 2008,2009 Toni Gundogdu.
 * Perl/$perl_v
Modules:
 * Crypt::PasswdMD5/$Crypt::PasswdMD5::VERSION\t\t* Crypt::Twofish2/$Crypt::Twofish2::VERSION
 * Crypt::Salt/$Crypt::Salt::VERSION\t\t* Config::Tiny/$Config::Tiny::VERSION
Core modules:
 * Getopt::Long/$Getopt::Long::VERSION\t\t* Encode/$Encode::VERSION
 * File::Spec/$File::Spec::VERSION\t\t* File::Find/$File::Find::VERSION
 * Pod::Usage/$Pod::Usage::VERSION\t\t* Digest::MD5/$Digest::MD5::VERSION
 * MIME::Base64/$MIME::Base64::VERSION
"; exit;
}

__END__

=head1 NAME

clivepass - the login password utility for clive

=head1 SYNOPSIS

clivepass [option]...

=head1 DESCRIPTION

clivepass is an utility that can be used to create and change passwords
for websites used by L<clive(1)>. The passwords are encrypted and saved
along with the username information. Access is restricted by using a
global passphrase.

Historically, a similar utility, clive-passwd, was part of clive 1.x but
was written in Python instead of Perl.

=head1 OPTIONS

B<Basic Options>

=over 4

=item B<-h --help>

Show help and exit.

=item B<-v --version>

Show version and exit.

=item B<-c --create>

Create a new passwd file. See also L</FILES>.

=item B<-a --add=>I<username>

Add a new login with the I<username>.

=item B<-e --edit=>I<username>

Change login password for I<username>.

=item B<-g --get=>I<username>

Print the decrypted login password for the I<username>
to STDOUT.

=item B<-s --show>

Show all saved login usernames with encrypted passwords.

=item B<-d --delete=>I<username>

Delete the login with the I<username>.

=back

=head1 EXAMPLES

=over 4

=item % clivepass -a myusername

=item % clivepass -g myusername

=back

=head1 FILES

clivepass searches the ~/.config/clive-utils directory for the config file.
You can override this by setting the B<CLIVEPASS_HOME> environment variable.

=over 4

=item ~/.config/clive-utils/passwd

Password file. Contains the salted passphrase hash and login usernames and
encrypted passwords.

=head1 SEE ALSO

L<clive(1)> L<clivescan(1)> L<clivefeed(1)>

=head1 OTHER

Project: http://googlecode.com/p/clive-utils/

A clive-utils development repository can be obtained from:

    % git clone git://repo.or.cz/clive-utils.git

Patches welcome.

=head1 AUTHOR

Written by Toni Gundogdu <legatvs@gmail.com>

=cut
